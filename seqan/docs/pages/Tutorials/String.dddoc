.Page.Sequences:
..order:100
..XXXcat:Tutorials
..summary:Sequences in SeqAn.

.Page.Sequences.description:
..contents

..image:sequences

..text:Sequences are at the core of SeqAn.
This tutorial gives an overview of the sequence types available in SeqAn. 
Algorithms to process and manipulate sequences are briefly presented.


..section:# Sequence Classes
..subsection:#.# Strings
..text:@Class.String.Strings@ are @Concept.Container.containers@ that store a sequence of values, for example 
a sequence of $char$, @Spec.Dna.nucleotides@, or @Spec.AminoAcid.amino acids@. 
The user of SeqAn can choose between several kinds of strings that are presented and discussed below.
All strings support different value types (i.e. alphabets). It is important to note that the string type
does not restrict the use of any value type.

Typically, the value type is specified as the first template argument.
..code:String<AminoAcid> myProteine;

..text:SeqAn offers many functions and operators for initializing, converting, manipulating, and printing strings.
..code:
String<char> str = "this is ";
str += "a test.";
::std::cout << str;
::std::cout << length(str);
..text:
More examples can be found in the @Demo.String Basics.String demo@.

..text:The user can specify the kind of string that should be used in an optional second template argument of @Class.String@.
There are the following specializations of @Class.String@ available.

..tableheader:Specialization|Description|Applications|Limitations
..table:@Spec.Alloc String@
|Expandable string that is stored on the heap.
|The default string implementation that can be used for general purposes.
|Changing the @Function.capacity@ can be very costly since all values must be copied.
..table:@Spec.Array String@
|Fast but non-expandable string.
|Fast storing of fixed-size sequences.
|@Function.capacity|Capacity@ must already be known at runtime. Not suitable for storing large sequences.
..table:@Spec.Block String@
|String that stores its sequence characters in blocks
|The @Function.capacity@ of the string can quickly be increased.
Good choice for growing strings or stacks.
|Iteration and random access to values is slightly slower than for @Spec.Alloc String|Alloc Strings@.
..table:@Spec.Packed String@
|A string that stores as many values in one machine word as possible.
|Suitable for storing large strings in memory.
|Slower than other in-memory strings.
..table:@Spec.External String@
|String that is stored in secondary memory.
|Suitable for storing very large strings (>2GB).
Parts of the string are automatically loaded from secondary memory on demand.
|Slower than other string classes.
..table:@Spec.CStyle String@
|Allows adaption of strings to C-style strings.
|Used for transforming other String classes into C-style strings (i.e. null terminated $char$ arrays).
Could be useful for calling functions of C-libraries.
|Only reasonable if value type is $char$ or $wchar_t$.

..text:Examples.
..code:
//String with maximum length 100.
String<char, Array<100> > myArrayString;
//String that takes only 2 bits per nucleotide.
String<Dna, Packed<> > myPackedString;


..subsection:#.# Sequence Adaptions
..text:SeqAn offers an interface for accessing @Adaption.std::basic_string|standard library strings@ and @Adaption.char array|c-style $char$ arrays@. Hence those built-in types can be handled in the same way as @Class.String|SeqAn strings@.
..code:
::std::string str1 = "a standard library string";
::std::cout << length(str1);

char str2[] = "this is a char array";
::std::cout << length(str2);


..subsection:#.# Segments
..text: Segments are continuous subsequences that represent parts of other sequences.
There are three kinds of segments in SeqAn: @Function.infix.infixes@, @Function.prefix.prefixes@, and @Function.suffix.suffixes@.
The metafunctions @Metafunction.Infix@, @Metafunction.Prefix@, and @Metafunction.Suffix@, respectively, return for a given sequence type the appropriate segment data type.
..code:
String<AminoAcid> prot = "AAADDDEEE";
Suffix<String<AminoAcid> >::Type suf = suffix(prot, 3);
::std::cout << suf;

..text: The segment is NOT a copy of the sequence segment. That is, changing the segment implies changing the host sequence.
..code:
String<char> str = "start_middle_end";
//We overwrite "middle"
infix(str, 6, 12) = "overwrite";
::std::cout << str;

..text: If this effect is undesirable, one has to explicitely make a copy of the string.

..section:# Working with Sequences
..subsection:#.# Iterators
..text:@Concept.Iterator|Iterators@ are objects that are used to scan through @Concept.Container|containers@ like @Class.String|strings@ or @Class.Segment|segments@.
For a given container class the metafunction @Metafunction.Iterator@ returns an appropriate iterator.
An iterator always points to one value in the container.
The function @Function.value@ (which does the same as the operator $*$) can be used to access this value.
Functions like @Function.goNext@ or @Function.goPrevious@ (which do the same as $++$ and $--$, respectively)
can be used to move the iterator to other values within the container.
..text:The functions @Function.begin@ and @Function.end@ applied to a container return iterators to the begin and the end of the container.
Note that, similar to C++ standard library iterators, the iterator returned by @Function.end@ does not points to the last value of the container but to the value that would come next.
So if $s$ is empty, then $end(s) == begin(s)$.
..text:
The following code that prints out a sequence demonstrates a typical iteration through a string:
..code:
String<char> str = "acgt";
typedef Iterator<String<char> >::Type TIterator;
for (TIterator it = begin(str); it != end(str); ++it)
{
    cout << value(it);
}
..text:
See @Demo.Iterator Basics|this demo program@ for more examples.


..subsection:#.# Comparisons
..text:
Two sequences can be lexicographically compared using usual operators like $<$ or $>=$, for example:
..code:
String<char> a      = "beta";
String<char> b      = "alpha";

bool a_not_equals_b = (a != b);     //true
bool a_less_b       = (a < b);      //false

..text:
Each comparison involves a scan of the two sequences for searching the first mismatch between the strings. This could be costly if the two sequences share a long common prefix.
Suppose we want to branch in a program depending on whether $a < b$, $a == b$, or $a > b$, for example:
..code:
if (a < b)      { /* code for case "a < b"  */ }
else if (a > b) { /* code for case "a > b"  */ }
else            { /* code for case "a == b" */ }
..text:
In this case, although only one scan would be enough to decide what case is to be applied, each operator $>$ and $<$ performs a new comparison.
SeqAn offers @Class.Lexical.lexicals@ to avoid unnecessary sequence scans.
Lexicals can store the result of a comparison, for example:
..code:
Lexical<> comp(a, b);   //compare a and b and store the result in comp

if (isLess(comp))           { /* code for case "a < b"  */ }
else if (isGreater(comp))   { /* code for case "a > b"  */ }
else                        { /* code for case "a == b" */ }

..subsection:#.# Expansion
..text:
Each sequence object has a @Function.capacity@, i.e. the maximum @Function.length@ of a sequence that can be stored in this object.
While some sequence types like @Spec.Array String@ or @Adaption.char array@ have a fixed capacity,
the capacity of other sequence classes like @Spec.Alloc String@ or @Adaption.std::basic_string@ can be changed at runtime.
Capacity can either be set explicitly by functions like @Function.reserve@ or @Function.resize@, or implicitly changed
if a function like @Function.append@ or @Function.replace@ has a result that would be too long for the target string.
There are several @Tag.Overflow Strategy.overflow strategies@ that determine what actually happens when a string should be expanded beyond its capacity.
If no @Tag.Overflow Strategy.overflow strategy@ is specified for a function call, a default overflow strategy is selected depending on the type of the sequence.
..text:Example:
..code:
String<char> str;
resize(str, 5, Exact());                    //sets capacity of str to 5
assign(str, "abcdefghijklmn", Limit());     //only "abcde" is assigned to str, since str is limited to 5
append(str, "ABCDEFG");                     //Use default expansion strategy: now str == "abcdeABCDEFG"

..subsection:#.# Conversion
..text:
A sequence of type $A$ values can be converted into a sequence of type $B$ value, if $A$ can be converted into $B$.
SeqAn offers three different ways for conversion:
..text:
1. Copy conversion. The source sequence is copied into the target sequence. This can be done by assignment (operator $=$) or using the function @Function.assign@, for example:
..code:
String<Dna> source = "acgtgcat";
String<char> target;
assign(target, source);     //copy conversion is done here

..text:
2. Move conversion. If the source sequence is not needed any more after the conversion, it is always advisable to use @Function.move@ instead of @Function.assign@.
@Function.move@ need not to make a copy but can re-use the source sequence storage.
In some cases, @Function.move@ can also perform an in-place conversion, for example: 
..code:
String<Dna> source = "acgtgcat";
String<char> target;
move(target, source);       //the in-place move conversion is done here

..text:
3. Modifier conversion. Instead of creating an actual target sequence, use a @Page.Modifiers|modifier (see the tutorial)@ to 'emulate' a sequence with a different value type, 
i.e. the modifier $target$ in the following example behaves exactly like a $char$ sequence:
..code:
String<Dna> source = "acgtgcat";
typedef Modifier<String<Dna>, ModView<FunctorConvert<Dna, char> > > TDnaToCharModifier;
TDnaToCharModifier target(source);      //this is a sequence of char that contains "acgtgcat"
Value<TDnaToCharModifier>::Type c;      //defines a variable of type char

..subsection:#.# Input/Output
..text:SeqAn offers several Ways for loading and saving sequences in many formats.
For more information, see @Page.Files|here@.


..section:# Gapped Sequences
..text:
SeqAn contains a special class @Class.Gaps@ for storing sequences that contain gaps, e.g. lines in sequence alignments. See @Page.Alignments|here@ for more information. 

..XXXXtext:For simplification, SeqAn predefines several string for usual value types:
..XXXtable:@Shortcut.CharString@|A string for storing text. The value type is $char$. If unicode characters are needed, @Shortcut.UnicodeString@ could be used.
..XXXtable:@Shortcut.DnaString@|A string for storing DNA. The value type is @Spec.Dna@, that can store the four values 'A', 'C', 'G', and 'T'. If a fifth value 'N' (for 'not known') should also be allowed, you can use @Shortcut.Dna5String@.
..XXXtable:@Shortcut.Peptide@|A string for storing proteine sequences. The value type is @Spec.AminoAcid@.
