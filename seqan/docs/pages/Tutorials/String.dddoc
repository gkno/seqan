.Page.Sequences:
..order:100
..cat:Tutorials
..summary:Sequences in SeqAn.

.Page.Sequences.description:
..contents

..image:sequences

..text:Sequences are the core of SeqAn.
This tutorial gives an overview of the variety of sequences types in SeqAn and basic manipulation algorithm.


..section:# Sequence Classes
..subsection:#.# Strings
..text:@Class.String.Strings@ are @Concept.Container.containers@ that store sequences of values, for example of $char$, @Spec.Dna.nucleotides@, or @Spec.AminoAcid.amino acids@. 
The user of SeqAn can choose between several kinds of strings (see below for the different string implementations SeqAn offers)
 and different values (i.e. alphabets). There is no restriction for the use of any combination of values and kinds of strings.

Typically, the value type is qualified as the first template argument, i.e. in angled brackets:
..code:String<AminoAcid> myProteine;

..text:SeqAn predefines @Shortcut|shortcuts@ for some usual value types, so we can also write:
..code:Peptide myProteine;

..text:SeqAn offers many functions and operators for initializing, converting, manipulating, and printing strings.
For example:
..code:
String<char> str = "this is ";
str += "a test.";
cout << str;                    //output: "this is a test."
cout << length(str);            //output: 15
..text:
For more examples see @Demo.String Basics.this demo program@.

..text:The user can specify the kind of string that should be used in an optional second template argument of @Class.String@.
There are the following kinds of string:

..tableheader:Specialization|Description|Applications|Limitations
..table:@Spec.Alloc String@
|Expandable string that is stored on heap.
|The default string implementation that can be used for general purposes.
|Changing the @Function.capacity@ can be very costly.
..table:@Spec.Array String@
|Fast but non-expandable string.
|Fast storing of small sequences.
|@Function.capacity|Capacity@ must already be known at runtime. Not suitable for storing large sequences.
..table:@Spec.Block String@
|String that stores its content in blocks
|The @Function.capacity@ of the string can quickly be increased.
Good choice for growing strings and for stacks.
|Random access to values is slightly slower than for @Spec.Alloc String|Alloc Strings@.
..table:@Spec.Packed String@
|A string that stores as many values in one machine word as possible.
|Suitable for storing large strings in memory.
|Slower than other in-memory strings.
..table:@Spec.External String@
|String that is stored on secondary memory.
|Suitable for storing very large strings (>2GB).
Parts of the string are automatically loaded from secondary memory when needed.
|Slower than other string classes.
..table:@Spec.CStyle String@
|Allows adaption of strings to C-style strings.
|Used for transforming other String classes into C-style strings (i.e. null terminated $char$ arrays).
Could be usefull for calling functions of C-libraries.
|Only reasonable if value type is $char$ or $wchar_t$.

..text:For example:
..code:
String<char, Array<100> > myArrayString;    //string with maximum length 100
String<Dna, Packed<> > myPackedString;      //string that takes only 2 bits per nucleotide


..subsection:#.# Sequence Adaptions
..text:SeqAn offers an interface for accessing @Adaption.std::basic_string|standard library strings@ and @Adaption.char array|c-style $char$ arrays@. Hence those built-in types can be handled in the same way as @Class.String|SeqAn strings@.
For example:
..code:
std::basic_string str1 = "a standard library string";
cout << length(str1);           //output: 25

char str2[] = "this is a char array";
cout << length(str2);           //output: 20


..subsection:#.# Segments
..text: Segments are sequences that represent parts of other sequences.
There are three kinds of segments in SeqAn: @Function.infix.infixes@, @Function.prefix.prefixes@, and @Function.suffix.suffixes@.
The metafunctions @Metafunction.Infix@, @Metafunction.Prefix@, and @Metafunction.Suffix@, respectively, return for a given sequence  an appropriate data type for storing the segment. For example:
..code:
Peptide prot = "AAADDDEEE";
Suffix<Peptide>::Type suf = suffix(prot, 3);
cout << suf;                                    //output: "DDDEEE"

..text: The segment does not create a copy of the sequence. Changing the segment also changes its host sequence, for example:
..code:
CharString str = "start_middle_end";
infix(str, 6, 12) = "overwrite";                //overwrites "middle"
cout << str;                                    //output: "start_overwrite_end";

..text: If this effect is undesirable, one has to explicitely make a copy of the string.

..section:# Working with Sequences
..subsection:#.# Iterators
..text:@Concept.Iterator|Iterators@ are objects that are used to scan through @Concept.Container|containers@ like @Class.String|strings@ or @Class.Segment|segments@.
For a given container class the metafunction @Metafunction.Iterator@ returns an appropriate iterator.
An iterator always points to one value in the container.
The function @Function.value@ (which does the same as the operator $*$) can be used to access this value.
Functions like @Function.goNext@ or @Function.goPrevious@ (which do the same as $++$ and $--$, respectively)
can be used to move the iterator to other values within the container.
..text:The functions @Function.begin@ and @Function.end@ applied to a container return iterators to the begin and the end of the container.
Note that, similar to C++ standard library iterators, the iterator returned by @Function.end@ does not points to the last value of the container but to the value that would come next.
So if $s$ is empty, then $end(s) == begin(s)$.
..text:
The following code that prints out a sequence demonstrates a typical iteration through a string:
..code:
String<char> str = "acgt";
typedef Iterator<String<char> >::Type TIterator;
for (TIterator it = begin(str); it != end(str); ++it)
{
    cout << value(it);
}
..text:
See @Demo.Iterators.this demo program@ for more examples.
..text:(rooted iterators)

..subsection:#.# Comparisons
..text:
Two sequences can be lexicographically compared using usual operators like $<$ or $>=$, for example:
..code:
String<char> a      = "beta";
String<char> b      = "alpha";

bool a_not_equals_b = (a != b);     //true
bool a_less_b       = (a < b);      //false

..text:
Each comparison involes a scan of the two sequences for searching the first mismatch between the strings. This could be costly if the two sequences share a long common prefix.
Suppose we want to act in different ways depending on $a < b$, $a == b$, or $a > b$, for example:
..code:
if (a < b)      { /* code for case "a < b"  */ }
else if (a > b) { /* code for case "a > b"  */ }
else            { /* code for case "a == b" */ }
..text:
In this case, although only one scan would be enough to decide what case is to be applied, each operator $>$ and $<$ performs a new comparison.
SeqAn offers @Class.Lexical.lexicals@ to avoid unnecessary sequence scans.
Lexicals can store the result of a comparison, for example:
..code:
Lexical<> comp(a, b);   //compare a and b and store the result in comp

if (isLess(comp))           { /* code for case "a < b"  */ }
else if (isGreater(comp))   { /* code for case "a > b"  */ }
else                        { /* code for case "a == b" */ }

..subsection:#.# Expansion
..text:
Each sequence object has a @Function.capacity@, i.e. the maximum @Function.length@ of a sequence that can be stored in this object.
While some sequence types like @Spec.Array String@ or @Adaption.char array@ have a fixed capacity,
the capacity of other sequence classes like @Spec.Alloc String@ or @Adaption.std::basic_string@ can be changed at runtime.
Capacity can either be set explicitly by functions like @Function.reserve@ or @Function.resize@, or implicitly changed
if a function like @Function.append@ or @Function.replace@ has a result that would be too long for the target string.
There are several @Tag.Overflow Strategy.overflow strategies@ that determine what actually happens when a string should be expanded beyond its capacity.
If no @Tag.Overflow Strategy.overflow strategy@ is specified for a function call, a default overflow strategy is selected depending on the type of the sequence.
..text:Example:
..code:
String<char> str = "12345";
append(str, "abcdefghijklmn", Limit());  //limits str to its current capacity
append(str, "ABCDEFG");                  //use default expansion strategy

..subsection:#.# Conversion
..text:
A sequence of type $A$ values can be converted into a sequence of type $B$ value, if $A$ can be converted into $B$.
SeqAn offers three different ways for conversion:
..text:
1. Copy conversion. The source sequence is copied into the target sequence. This can be done by assignment (operator $=$) or using the function @Function.assign@, for example:
..code:
String<Dna> source = "acgtgcat";
String<char> target;
assign(target, source);     //copy conversion is done here

..text:
2. Move conversion. If the source sequence is not needed any more after the conversion, it is always advisable to use @Function.move@ instead of @Function.assign@.
@Function.move@ need not to make a copy but can re-use the source sequence storage.
In some cases, @Function.move@ can also perform an in-place conversion, for example: 
..code:
String<Dna> source = "acgtgcat";
String<char> target;
move(target, source);       //the in-place move conversion is done here

..text:
3. Modifier conversion. Instead of creating an actual target sequence, use a @Page.Modifiers@ to 'emulate' a sequence with a different value type, for example:
..code:
String<Dna> source = "acgtgcat";
Modifier<String<Dna>, ModView<FunctorConvert<Dna, char> > > target(source);

..subsection:#.# Input/Output
..text:SeqAn offers several Ways for loading and saving sequences in many formats.
For more information, see @Pages.Files|here@.


..section:# Gapped Sequences
..text:
SeqAn contains a special class @Class.Gaps@ for storing sequences that contain gaps, e.g. lines in sequence alignments. See @Page.Alignments|here@ for more information. 

..XXXXtext:For simplification, SeqAn predefines several string for usual value types:
..XXXtable:@Shortcut.CharString@|A string for storing text. The value type is $char$. If unicode characters are needed, @Shortcut.UnicodeString@ could be used.
..XXXtable:@Shortcut.DnaString@|A string for storing DNA. The value type is @Spec.Dna@, that can store the four values 'A', 'C', 'G', and 'T'. If a fifth value 'N' (for 'not known') should also be allowed, you can use @Shortcut.Dna5String@.
..XXXtable:@Shortcut.Peptide@|A string for storing proteine sequences. The value type is @Spec.AminoAcid@.
