#!/usr/bin/env python
"""Execute the tests for the seqan_tcoffee program.

The golden test outputs are generated by the script generate_outputs.sh.

You have to give the root paths to the source and the binaries as arguments to
the program.  These are the paths to the directory that contains the 'projects'
directory.

Usage:  run_tests.py SOURCE_ROOT_PATH BINARY_ROOT_PATH
"""
import logging
import os.path
import sys

import seqan.app_tests as app_tests

# Path of the binary under test, relative to the checkout.
BINARY = 'projects/library/cmake/apps/seqan_tcoffee'


def main(source_base, binary_base):
    """Main entry point of the script."""

    print 'Executing test for seqan_tcoffee'
    print '================================'
    print
    
    ph = app_tests.TestPathHelper(
        source_base, binary_base,
        'projects/tests/apps/seqan_tcoffee')  # tests dir

    # Build list with TestConf objects, analoguely to how the output
    # was generated in generate_outputs.sh.
    conf_list = []

    # ============================================================
    # Run on Proteins (Balibase).
    # ============================================================

    # Run with defaults for all non-mandatory options.
    for fname in ['1aab', '1ad2', '2trx']:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.out' % fname)],
            to_diff=[(ph.inFile('%s.out' % fname),
                      ph.outFile('%s.out' % fname))])
        conf_list.append(conf)

    # Run with explicit alphabet.
    for fname in ['1aab', '1ad2', '2trx']:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-a', 'protein',
                  '-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.protein.out' % fname)],
            to_diff=[(ph.inFile('%s.protein.out' % fname),
                      ph.outFile('%s.protein.out' % fname))])
        conf_list.append(conf)

        # Run with different segment match generation options.  We run
    # with with single values and combinations of neighbours
    for fname in ['1aab', '1ad2', '2trx']:
        for m in ['global', 'local', 'overlap', 'lcs', 'global,local',
                  'local,overlap', 'overlap,lcs', 'global,lcs']:
            conf = app_tests.TestConf(
                program=os.path.join(ph.binary_base_path, BINARY),
                args=['-m', m,
                      '-s', ph.inFile('%s.fa' % fname),
                      '-o', ph.outFile('%s.m%s.out' % (fname, m))],
                to_diff=[(ph.inFile('%s.m%s.out' % (fname, m)),
                          ph.outFile('%s.m%s.out' % (fname, m)))])
            conf_list.append(conf)

    # Run with different match files variations.
    # TODO

    # Run with different scoring options.
    for fname in ['1aab', '1ad2', '2trx']:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-g', '-20',
                  '-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.g-20.out' % fname)],
            to_diff=[(ph.inFile('%s.g-20.out' % fname),
                      ph.outFile('%s.g-20.out' % fname))])
        conf_list.append(conf)
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-e', '-5',
                  '-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.e-5.out' % fname)],
            to_diff=[(ph.inFile('%s.e-5.out' % fname),
                      ph.outFile('%s.e-5.out' % fname))])
        conf_list.append(conf)
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-ms', '10',
                  '-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.ms10.out' % fname)],
            to_diff=[(ph.inFile('%s.ms10.out' % fname),
                      ph.outFile('%s.ms10.out' % fname))])
        conf_list.append(conf)
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-mm', '-8',
                  '-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.mm-8.out' % fname)],
            to_diff=[(ph.inFile('%s.mm-8.out' % fname),
                      ph.outFile('%s.mm-8.out' % fname))])
        conf_list.append(conf)

    # Run with matrix file.
    for fname in ['1aab', '1ad2', '2trx']:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-ma', ph.inFile('VTML200I'),
                  '-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.maVTML200.out' % fname)],
            to_diff=[(ph.inFile('%s.maVTML200.out' % fname),
                      ph.outFile('%s.maVTML200.out' % fname))])
        conf_list.append(conf)

    # Run with manual guide tree.
    for fname in ['1aab', '1ad2', '2trx']:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-u', ph.inFile('%s.newick' % fname),
                  '-s', ph.inFile('%s.fa' % fname),
                  '-o', ph.outFile('%s.u.out' % fname)],
            to_diff=[(ph.inFile('%s.u.out' % fname),
                      ph.outFile('%s.u.out' % fname))])
        conf_list.append(conf)

    # Run with different guide tree building options.
    for fname in ['1aab', '1ad2', '2trx']:
        for b in ['nj', 'min', 'max', 'avg', 'wavg']:
            conf = app_tests.TestConf(
                program=os.path.join(ph.binary_base_path, BINARY),
                args=['-b', b,
                      '-s', ph.inFile('%s.fa' % fname),
                      '-o', ph.outFile('%s.b%s.out' % (fname, b))],
                to_diff=[(ph.inFile('%s.b%s.out' % (fname, b)),
                          ph.outFile('%s.b%s.out' % (fname, b)))])
            conf_list.append(conf)

    # Run alignment evaluation.
    for fname in ['1aab', '1ad2', '2trx']:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-i', ph.inFile('%s.out' % fname)],
            redir_stdout=ph.outFile('%s.i.out' % fname),
            to_diff=[(ph.inFile('%s.i.out' % fname),
                      ph.outFile('%s.i.out' % fname))])
        conf_list.append(conf)

    # ============================================================
    # Run on DNA (Adenoviruses).
    # ============================================================

    # Run with defaults for all non-mandatory options.
    for i in [2, 3, 4]:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-a', 'dna',
                  '-s', ph.inFile('adeno%d.fa' % i),
                  '-o', ph.outFile('adeno%d.out' % i)],
            to_diff=[(ph.inFile('adeno%d.out' % i),
                      ph.outFile('adeno%d.out' % i))])
        conf_list.append(conf)

    # ============================================================
    # Run on RNA.
    # ============================================================

    # Run with defaults for all non-mandatory options.
    for i in [2, 3, 4]:
        conf = app_tests.TestConf(
            program=os.path.join(ph.binary_base_path, BINARY),
            args=['-a', 'rna',
                  '-s', ph.inFile('adeno%d-rna.fa' % i),
                  '-o', ph.outFile('adeno%d-rna.out' % i)],
            to_diff=[(ph.inFile('adeno%d-rna.out' % i),
                      ph.outFile('adeno%d-rna.out' % i))])
        conf_list.append(conf)
    
    # Execute the tests.
    failures = 0
    for conf in conf_list:
        res = app_tests.runTest(conf)
        # Output to the user.
        print ' '.join(['seqan_tcoffee'] + conf.args),
        if res:
             print 'OK'
        else:
            failures += 1
            print 'FAILED'
    print
    print '=============================='
    print '     total tests: %d' % len(conf_list)
    print '    failed tests: %d' % failures
    print 'successful tests: %d' % (len(conf_list) - failures)
    print '=============================='
    # Compute and return return code.
    return failures != 0


if __name__ == '__main__':
#    logging.root.setLevel(logging.DEBUG)
    if len(sys.argv) != 3:
        print >>sys.stderr, 'ERROR: Invalid arguments!'
        print >>sys.stderr, 'Usage: run_tests SOURCE_ROOT_PATH BINARY_ROOT_PATH'
        sys.exit(2)
    sys.exit(main(sys.argv[1], sys.argv[2]))
